<?xml version="1.0" encoding="UTF-8" ?> 
<Module>
  <ModulePrefs title="screencasts"/> 
  <Content type="html">
  <![CDATA[
<a name=slide0></a>Slide 0: &lt;&lt; Previous <a href=#slide0h>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img0.png border=1 >
</td><td valign=top>
<p>Welcome!</p>
<p></p>
<p>I'm Ange Albertini, and I will talk about x86 and PE</p>
</td></tr></table>

<a name=slide0h></a>Slide 0h: <a href=#slide0>&lt;&lt; Previous</a> <a href=#slide1>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img0h.png border=1 >
</td><td valign=top>
<p>this extra slide to let you decide if you really want to 
 read further ;)</p>
<ol>
<li/>I studied ASM and PE, from scratch
<li/>I failed all tools I tried: IDA, OllyDbg, Hiew, pefile, WinDbg, HT, CFF Explorer...
<li/>here are a few of my findings
</ol>
 </td></tr></table>

<a name=slide1></a>Slide 1: <a href=#slide0>&lt;&lt; Previous</a> <a href=#slide2>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img1.png border=1 >
</td><td valign=top>
<p>This is an improved version of my presentation at Hashdays.</p>
<p>I reworked it, but most of the content is still the same.</p>
</td></tr></table>


<a name=slide2></a>Slide 2: <a href=#slide1>&lt;&lt; Previous</a> <a href=#slide3>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img2.png border=1 >
</td><td valign=top>
<p>I created Corkami, a website about reverse engineering.</p>
<p></p>
<p>it's technical, and free: open-source, relying on free tools, free for commercial use, no ads, no log-in.</p>
<p></p>
<p>I focus on creating a LOT of small focused PoCs. they're handmade so really no extra stuff. each of them is probably meaningless, but altogether, they're a useful toolbox to test and learn.</p>
<p>then I write a summary page. but I put more work in PoCs than in the pages.</p>
<p></p>
<p>the important is: for each feature I study, there's a PoC available</p>
<p></p>
<p>but it's only a hobby, so it's quite messy, and not as good as I'd like it to be.</p>
</td></tr></table>


<a name=slide3></a>Slide 3: <a href=#slide2>&lt;&lt; Previous</a> <a href=#slide4>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img3.png border=1 >
</td><td valign=top>
<p>so, whether it's: </p>
<ul>
<li/>a non PE exe with an inverted ZM signature, in 16bits asm.
<li/>a complete 'correct' PDF with text (that's the full PDF btw), typed in notepad
<li/>a working java class, with opcodes generated manually
<li/>a tiny PE, with imports and code in the middle of the header
</ul>
<p>you can see that all of them only have the necessary elements.</p>
</td></tr></table>


<a name=slide4></a>Slide 4: <a href=#slide3>&lt;&lt; Previous</a> <a href=#slide5>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img4.png border=1 >
</td><td valign=top>
<p>and here is the story behind this presentation</p>
</td></tr></table>


<a name=slide5></a>Slide 5: <a href=#slide4>&lt;&lt; Previous</a> <a href=#slide6>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img5.png border=1 >
</td><td valign=top>
<p>first, a small flashback</p>
</td></tr></table>


<a name=slide6></a>Slide 6: <a href=#slide5>&lt;&lt; Previous</a> <a href=#slide7>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img6.png border=1 >
</td><td valign=top>
<p>years ago, I was young and innocent, believing that CPU would be perfect, because they're made of transistor, not software.</p>
<p></p>
<p>and I thought I knew assembly.</p>
</td></tr></table>


<a name=slide7></a>Slide 7: <a href=#slide6>&lt;&lt; Previous</a> <a href=#slide8>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img7.png border=1 >
</td><td valign=top>
<p>then I encountered my first undocumented opcodes. and shortly after, my first sectionless PE.</p>
<p></p>
<p>I was shocked, but I thought I was still young...</p>
</td></tr></table>


<a name=slide8></a>Slide 8: <a href=#slide7>&lt;&lt; Previous</a> <a href=#slide9>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img8.png border=1 >
</td><td valign=top>
<p>So I decided to go back to the basics, studying x86 and PE from scratch.</p>
</td></tr></table>


<a name=slide9></a>Slide 9: <a href=#slide8>&lt;&lt; Previous</a> <a href=#slide10>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img9.png border=1 >
</td><td valign=top>
<p>and writing my findings on the way, on Corkami.</p>
</td></tr></table>


<a name=slide10></a>Slide 10: <a href=#slide9>&lt;&lt; Previous</a> <a href=#slide11>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img10.png border=1 >
</td><td valign=top>
<p>This talk is only a subset of what's available on the site, even on these topics.</p>
</td></tr></table>


<a name=slide11></a>Slide 11: <a href=#slide10>&lt;&lt; Previous</a> <a href=#slide12>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img11.png border=1 >
</td><td valign=top>
<p>but, if I was just a guy learning ASM and PE, I probably wouldn't be presenting here.</p>
<p></p>
<p>So, here is why I'm here :)</p>
<p></p>
<p>Most of these bugs were already reported and fixed.</p>
</td></tr></table>


<a name=slide12></a>Slide 12: <a href=#slide11>&lt;&lt; Previous</a> <a href=#slide13>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img12.png border=1 >
</td><td valign=top>
<p>so, first, I'll start slowly, trying to introduce assembly to beginners, and make them understand the problem of undocumented opcodes.</p>
<p></p>
<p>then, it will get more technical:</p>
<p>I'll cover a few assembly tricks, including some found in malware.</p>
<p></p>
<p>then I'll introduce my opcode tester, CoST.</p>
<p></p>
<p>and I'll also present my last project which deals with the PE format.</p>
</td></tr></table>


<a name=slide13></a>Slide 13: <a href=#slide12>&lt;&lt; Previous</a> <a href=#slide14>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img13.png border=1 >
</td><td valign=top>
<p>So, let's start and try to make everybody understand the problem of undocumented opcodes.</p>
<p></p>
<p>so first, introduce opcodes themselves</p>
</td></tr></table>


<a name=slide14></a>Slide 14: <a href=#slide13>&lt;&lt; Previous</a> <a href=#slide15>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img14.png border=1 >
</td><td valign=top>
<p>so, we create a simple program in a language, such as C.</p>
<p></p>
<p>Here, in Visual Studio, Microsoft standard development environment.</p>
<p></p>
<p>this program shows a simple message box on screen, then terminates.</p>
<p></p>
<p>an executable is generated, and indeed does what we expected.</p>
</td></tr></table>


<a name=slide15></a>Slide 15: <a href=#slide14>&lt;&lt; Previous</a> <a href=#slide16>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img15.png border=1 >
</td><td valign=top>
<p>what the Visual Studio compiler did from our C code is actually generate sequences of assembly code instruction that will generate the wanted actions.</p>
<p></p>
</td></tr></table>


<a name=slide16></a>Slide 16: <a href=#slide15>&lt;&lt; Previous</a> <a href=#slide17>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img16.png border=1 >
</td><td valign=top>
<p>so, the C code is turned into assembly. which is itself encoded in the binary as opcodes.</p>
</td></tr></table>


<a name=slide17></a>Slide 17: <a href=#slide16>&lt;&lt; Previous</a> <a href=#slide18>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img17.png border=1 >
</td><td valign=top>
<p>Here, you can see calls to MessageBox, then ExitProcess (the names are self-explaining), with the parameters above.</p>
<p></p>
<p>these assembly operations are stored in opcodes directly in the binary, as visible on the left.</p>
</td></tr></table>


<a name=slide18></a>Slide 18: <a href=#slide17>&lt;&lt; Previous</a> <a href=#slide19>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img18.png border=1 >
</td><td valign=top>
<p>now you know that this is what is in the file itself.</p>
<p>this is how it's read by 'us' (reverse engineers, malware analysts, exploit developers...).</p>
<p></p>
<p>the CPU itself only reads the opcodes.</p>
<p></p>
<p>as you can see, there is a relation:</p>
<ul>
<li/>68 - in binary - is used to push offsets
<li/>calls starts with FF 15...
<li/>and you can also see the addresses (read them backward).
</ul>
<p></p>
<p>so, you see the first byte determine the actual opcode.</p>
<p>and depending on each opcode, the length is variable.</p>
</td></tr></table>


<a name=slide19></a>Slide 19: <a href=#slide18>&lt;&lt; Previous</a> <a href=#slide20>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img19.png border=1 >
</td><td valign=top>
<p>This is what is actually in the file on the hard disk (the opcodes).</p>
<p></p>
<p>If you'd accidentally open the file in, say notepad - it doesn't really make sense, but at least you have that on your machine - you could find it here (remember, it's in binary).</p>
<p></p>
<p>Note that it's actually a very tiny part of the whole file (&lt;30bytes out of 56000).</p>
<p></p>
<p></p>
</td></tr></table>


<a name=slide20></a>Slide 20: <a href=#slide19>&lt;&lt; Previous</a> <a href=#slide21>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img20.png border=1 >
</td><td valign=top>
<p>What's important is that in the end, anything running on your machine is about the CPU executing opcode, no matter what.</p>
<p></p>
<p>the compiled file is full of 'unneeded' stuff. while you can make a much smaller file with exactly the same functionality (that's the whole file, on the right), and even though they're very different, the same opcodes are present again.</p>
</td></tr></table>


<a name=slide21></a>Slide 21: <a href=#slide20>&lt;&lt; Previous</a> <a href=#slide22>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img21.png border=1 >
</td><td valign=top>
<p>so, the compiler translates our C to a series of assembly operations, which is itself encoded in opcodes.</p>
<p>the resulting executable only contains the opcodes, which are directly understood and executed by the CPU. If no error happens, what is here directly affects the behavior of the program, there is no 'man in the middle' from the OS.</p>
<p></p>
<p>so our C code will just eventually lead the CPU to read and execute</p>
<p>6A 40 68 F4 20 40 00 68 FC 20...</p>
<p></p>
<p>if, by any chance, there is some opcodes that we are not aware of, or doesn't do what we expect, the CPU doesn't care, it just knows what to do.</p>
</td></tr></table>


<a name=slide22></a>Slide 22: <a href=#slide21>&lt;&lt; Previous</a> <a href=#slide23>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img22.png border=1 >
</td><td valign=top>
<p>so now, let's interfere with the compiling process</p>
</td></tr></table>


<a name=slide23></a>Slide 23: <a href=#slide22>&lt;&lt; Previous</a> <a href=#slide24>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img23.png border=1 >
</td><td valign=top>
<p>let's add a command that will force a specific byte in the opcodes.</p>
<p></p>
<p>this result is not known to visual studio, which only shows ??</p>
</td></tr></table>


<a name=slide24></a>Slide 24: <a href=#slide23>&lt;&lt; Previous</a> <a href=#slide25>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img24.png border=1 >
</td><td valign=top>
<p>indeed, if we check Intel official documentation, there is nothing to see here...</p>
</td></tr></table>


<a name=slide25></a>Slide 25: <a href=#slide24>&lt;&lt; Previous</a> <a href=#slide26>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img25.png border=1 >
</td><td valign=top>
<p>so, we forced something that is not recognized by the most expensive Microsoft compiler to execute, which is not even in Intel's books.</p>
<p></p>
<p>We should only expect a crash, right ?</p>
</td></tr></table>


<a name=slide26></a>Slide 26: <a href=#slide25>&lt;&lt; Previous</a> <a href=#slide27>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img26.png border=1 >
</td><td valign=top>
<p>but the CPU doesn't care about what YOU (or VS) know, and it just executes that mysterious D6 just fine (apparently)</p>
<p></p>
<p>it doesn't look like a big problem, but if like Microsoft, you base your judgment on Intel's documentation, you just don't know what happens next. No automated analysis, proactive detection, etc... and you need to understand that undocumented opcode.</p>
<p></p>
<p>You can't even skip it:</p>
<p>you don't know if it will jump, do nothing, trigger an exception...</p>
<p>and because of variable instruction length, you can't even tell what would be the next instruction, so you can't guess easily backward from the next instruction.</p>
</td></tr></table>


<a name=slide27></a>Slide 27: <a href=#slide26>&lt;&lt; Previous</a> <a href=#slide28>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img27.png border=1 >
</td><td valign=top>
<p>so what did we do in reality ?</p>
<p></p>
<p>D6 will be decoded as SETALC, which is quite simple.</p>
<p></p>
<p>It doesn't interfere with the execution of this example (it could have, of course).</p>
<p></p>
<p>surprisingly, it's not documented by Intel, but it's documented by AMD.</p>
<p></p>
<p>anyone knows why ?</p>
<p>I'd be curious to know.</p>
</td></tr></table>


<a name=slide28></a>Slide 28: <a href=#slide27>&lt;&lt; Previous</a> <a href=#slide29>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img28.png border=1 >
</td><td valign=top>
<p>the funny thing is, even though Intel docs are full of holes, Intel free tools are fully aware of what to expect...</p>
<p></p>
<p>Sadly, Microsoft WinDbg decided to follow the official docs, which makes it a very bad tool against malware, which commonly use undocumented tricks.</p>
</td></tr></table>


<a name=slide29></a>Slide 29: <a href=#slide28>&lt;&lt; Previous</a> <a href=#slide30>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img29.png border=1 >
</td><td valign=top>
<p>So, you now know that the CPU knows things that the Intel documentations omits.</p>
<p></p>
<p>if we or our tools are not able to tell what the CPU will do, we're just blind.</p>
</td></tr></table>


<a name=slide30></a>Slide 30: <a href=#slide29>&lt;&lt; Previous</a> <a href=#slide31>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img30.png border=1 >
</td><td valign=top>
<p>the extra problem is that each of this oddities are usually scattered in various files, deep under obfuscations or in malicious behavior. no 'ready to use' toolbox.</p>
<p></p>
<p>that's the hole I wanted to fill.</p>
</td></tr></table>


<a name=slide31></a>Slide 31: <a href=#slide30>&lt;&lt; Previous</a> <a href=#slide32>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img31.png border=1 >
</td><td valign=top>
<p>Now, let's start the real stuff</p>
</td></tr></table>


<a name=slide32></a>Slide 32: <a href=#slide31>&lt;&lt; Previous</a> <a href=#slide33>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img32.png border=1 >
</td><td valign=top>
<p>before focusing on particular opcodes,</p>
<p>my first questions were: </p>
<ul>
<li/>what are actually all the supported opcodes ?
<li/>then, actually how many registers are there ?
<li/>before anything happen, do they have any particular value ?
</ul>
</td></tr></table>


<a name=slide33></a>Slide 33: <a href=#slide32>&lt;&lt; Previous</a> <a href=#slide34>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img33.png border=1 >
</td><td valign=top>
<p>that's the problem. </p>
<p>like English language, assembly uses mainly always the same 'standard' opcodes.</p>
<p></p>
<p>which means, what everybody is used to hear or read:</p>
<p></p>
<p>Here, 'standard language'. What all generations understand.</p>
<p></p>
<p>most people would understand...</p>
</td></tr></table>


<a name=slide34></a>Slide 34: <a href=#slide33>&lt;&lt; Previous</a> <a href=#slide35>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img34.png border=1 >
</td><td valign=top>
<p>but Intel CPU are from the 70's and still backward compatible...</p>
<p></p>
<p>here is an example of Shakespeare English and old x86 mnemonics</p>
<p></p>
<p>unknown to most people.</p>
<p>yet still fully working on a modern CPU.</p>
</td></tr></table>


<a name=slide35></a>Slide 35: <a href=#slide34>&lt;&lt; Previous</a> <a href=#slide36>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img35.png border=1 >
</td><td valign=top>
<p>so here is a small executable where I only use uncommon opcodes. some are not really doing anything, some are actually doing something meaningful.</p>
<p></p>
<p>I expect that most of us are not even used to see these opcodes, yet they're fully supported by all CPUs.</p>
</td></tr></table>


<a name=slide36></a>Slide 36: <a href=#slide35>&lt;&lt; Previous</a> <a href=#slide37>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img36.png border=1 >
</td><td valign=top>
<p>Another funny fact is that some specific opcodes (interrupt) used to be for various functionality, which made IDA and Hiew over-interpret them.</p>
<p></p>
<p>in IDA, you can disable the option which is by default.</p>
</td></tr></table>


<a name=slide37></a>Slide 37: <a href=#slide36>&lt;&lt; Previous</a> <a href=#slide38>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img37.png border=1 >
</td><td valign=top>
<p>new generation : English and opcodes.</p>
<p></p>
<p>probably unknown to most people, only the new generation</p>
<p></p>
<p>single opcodes for CRC, AES, string masking...</p>
<p></p>
<p>MOVBE is an exception in itself:</p>
<p>it's only available on netbook. not on more recent CPUs like i7</p>
<p>=&gt; so much for backward compatibility</p>
</td></tr></table>


<a name=slide38></a>Slide 38: <a href=#slide37>&lt;&lt; Previous</a> <a href=#slide39>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img38.png border=1 >
</td><td valign=top>
<p>I made a 'non working' PoC with all opcodes encoded, and various tricky situation.</p>
<p></p>
<p>very useful to quickly test the abilities of a disassembler.</p>
</td></tr></table>


<a name=slide39></a>Slide 39: <a href=#slide38>&lt;&lt; Previous</a> <a href=#slide40>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img39.png border=1 >
</td><td valign=top>
<p>the basics of assembly are the registers...</p>
<p></p>
<p>registers are overlapping. </p>
<p>but unlike many documentations, ST0 actually overlaps MM7, not MM0</p>
<p></p>
<p>before any operation, registers have the value assigned to themselves by the OS.</p>
<p>I collected these values (under Windows). It's not CPU specific, but the initial values of the register on process start-up gives a few hint that are used by malwares:</p>
<ul>
<li/>
EAX can immediately tell if you're on an older OS or not.
<li/>
While GS can tell you if the machine is 64b or not, even in a 32b process.
</ul>
</td></tr></table>


<a name=slide40></a>Slide 40: <a href=#slide39>&lt;&lt; Previous</a> <a href=#slide41>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img40.png border=1 >
</td><td valign=top>
<p>I created a PoC that just gets all registers from EP and TLS, and checks the validity of result.</p>
<p></p>
<p>easy check see if a malware/tool is interfering with the loading process.</p>
</td></tr></table>


<a name=slide41></a>Slide 41: <a href=#slide40>&lt;&lt; Previous</a> <a href=#slide42>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img41.png border=1 >
</td><td valign=top>
<p>smsw is an old 286-era mnemonic (before protected mode was 'complete'): it allows usermode access to cr0.</p>
<p>the higher word of a reg32 target is 'undefined', yet always modified (and same as cr0)</p>
<p></p>
<p>under XP, right after an FPU operation, the returned value is modified [bits 1 and 3, called MP (Monitor Coprocessor) and TS (Task switched)], but eventually reverted after some time.</p>
<p></p>
<p>too tricky ? redirection fails. any idea why ?</p>
</td></tr></table>


<a name=slide42></a>Slide 42: <a href=#slide41>&lt;&lt; Previous</a> <a href=#slide43>&gt;&gt; Next</a>
<table><tr><td>
<OBJECT CLASSID="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" WIDTH="800" HEIGHT="602" CODEBASE="http://active.macromedia.com/flash5/cabs/swflash.cab#version=7,0,0,0"><PARAM NAME=movie VALUE=https://sites.google.com/site/corkami/download/smsw.swf><PARAM NAME=play VALUE=true><PARAM NAME=loop VALUE=false><PARAM NAME=wmode VALUE=transparent><PARAM NAME=quality VALUE=low><EMBED src=https://sites.google.com/site/corkami/download/smsw.swf WIDTH=800 HEIGHT=602 quality=low loop=false wmode=transparent TYPE="application/x-shockwave-flash" PLUGINSPAGE="http://www.macromedia.com/shockwave/download/index.cgi?P1_Prod_Version=ShockwaveFlash"></EMBED></OBJECT><br/>
</td><td valign=top>
<p>demo of smsw:</p>
<p>undocumented behavior</p>
<p>fpu relation (xp)</p>
<p>redirection weirdness</p>
</td></tr></table>


<a name=slide43></a>Slide 43: <a href=#slide42>&lt;&lt; Previous</a> <a href=#slide44>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img43.png border=1 >
</td><td valign=top>
<p>the GS trick is similar.</p>
<p>on 32b of windows, GS is reset on thread switch.</p>
<p>on 64b windows, it's already used by the OS (value non null at start)</p>
<p></p>
<p>ie wait long enough, it's null, whatever the value before.</p>
<p></p>
<p>if you just step manually, instantly lost.</p>
<p>after some time, but not a too short time, it's reset</p>
<p></p>
</td></tr></table>


<a name=slide44></a>Slide 44: <a href=#slide43>&lt;&lt; Previous</a> <a href=#slide45>&gt;&gt; Next</a>
<table><tr><td>
<OBJECT CLASSID="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" WIDTH="800" HEIGHT="602" CODEBASE="http://active.macromedia.com/flash5/cabs/swflash.cab#version=7,0,0,0"><PARAM NAME=movie VALUE=https://sites.google.com/site/corkami/download/gs.swf><PARAM NAME=play VALUE=true><PARAM NAME=loop VALUE=false><PARAM NAME=wmode VALUE=transparent><PARAM NAME=quality VALUE=low><EMBED src=https://sites.google.com/site/corkami/download/gs.swf WIDTH=800 HEIGHT=602 quality=low loop=false wmode=transparent TYPE="application/x-shockwave-flash" PLUGINSPAGE="http://www.macromedia.com/shockwave/download/index.cgi?P1_Prod_Version=ShockwaveFlash"></EMBED></OBJECT><br/>
</td><td valign=top>
<p>demo of all GS features</p>
</td></tr></table>


<a name=slide45></a>Slide 45: <a href=#slide44>&lt;&lt; Previous</a> <a href=#slide46>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img45.png border=1 >
</td><td valign=top>
<p>xchg eax, eax is 90, which originally did nothing.</p>
<p>(xchg eax, ecx is 91)</p>
<p>thus 90 became nop</p>
<p>but 87 c0 is an xchg eax, eax that is not a nop and does something in 64b, as it resets the upper dword.</p>
<p></p>
<p>hint nop gives hint of what to access next. it does nothing, but it's multi-byte. </p>
<p>first, it's not completely documented by intel</p>
<p>and, being a multi-byte opcode, if it overlaps an invalid page, it can trigger an exception!</p>
<p></p>
</td></tr></table>


<a name=slide46></a>Slide 46: <a href=#slide45>&lt;&lt; Previous</a> <a href=#slide47>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img46.png border=1 >
</td><td valign=top>
<p>Mov is documented, but has a few quirks.</p>
<p>* to/from control and debug registers, memory operands are not allowed. but not rejected !</p>
<p>* in 64b, with no REX prefix, movsxd can actually work to and from a 32b register, which is against the logic of 'sign extending'</p>
<p>* on the contrary, mov from a selector actually affects a complete 32b register. the upper word is theoretically undefined, but actually 0 (used by malware to see if upper part is actually reset or if wrongly emulated as 'mov ax, cs'.)</p>
</td></tr></table>


<a name=slide47></a>Slide 47: <a href=#slide46>&lt;&lt; Previous</a> <a href=#slide48>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img47.png border=1 >
</td><td valign=top>
<p>smsw (undocumented) gives full cr0 access.</p>
<p>then cr0 access with 'ignored' Mod/RM</p>
<p>then standard cr0 access...</p>
<p></p>
<p>same results, in all 3 cases.</p>
</td></tr></table>


<a name=slide48></a>Slide 48: <a href=#slide47>&lt;&lt; Previous</a> <a href=#slide49>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img48.png border=1 >
</td><td valign=top>
<p>Bswap... is like an administration... rules prevent it to work correctly most of the time...</p>
<p></p>
<p>it's supposed to swap the endianness of a register.</p>
<p></p>
<p>but most of the time, it does something unexpected.</p>
<p></p>
<p>with a 64b register, it swaps the quadword around. good.</p>
<p></p>
<p>with a 32b, it resets the highest dword. 'as usual', of course...</p>
<p></p>
<p>and on 16b, it's 'undefined' but it just clears the 16b register itself (the rest stays unchanged, of course)...</p>
</td></tr></table>

<a name=slide49></a>Slide 49: <a href=#slide48>&lt;&lt; Previous</a> <a href=#slide49b>&gt;&gt; Next</a> (32b)
<table><tr><td>
<p>Demo in 32 bits</p>
<OBJECT CLASSID="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" WIDTH="800" HEIGHT="602" CODEBASE="http://active.macromedia.com/flash5/cabs/swflash.cab#version=7,0,0,0"><PARAM NAME=movie VALUE=https://sites.google.com/site/corkami/download/demo32.swf><PARAM NAME=play VALUE=true><PARAM NAME=loop VALUE=false><PARAM NAME=wmode VALUE=transparent><PARAM NAME=quality VALUE=low><EMBED src=https://sites.google.com/site/corkami/download/demo32.swf WIDTH=800 HEIGHT=602 quality=low loop=false wmode=transparent TYPE="application/x-shockwave-flash" PLUGINSPAGE="http://www.macromedia.com/shockwave/download/index.cgi?P1_Prod_Version=ShockwaveFlash"></EMBED></OBJECT><br/>
</td><td valign=top>
<p>demo of nop / mov / bswap, in 32b </p>
</td></tr></table>

<a name=slide49b></a>Slide 49b: <a href=#slide49>&lt;&lt; Previous</a> <a href=#slide50>&gt;&gt; Next</a> (64b)
<table><tr><td>
<p>Demo in 64 bits</p>
<OBJECT CLASSID="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" WIDTH="800" HEIGHT="602" CODEBASE="http://active.macromedia.com/flash5/cabs/swflash.cab#version=7,0,0,0"><PARAM NAME=movie VALUE=https://sites.google.com/site/corkami/download/demo64.swf><PARAM NAME=play VALUE=true><PARAM NAME=loop VALUE=false><PARAM NAME=wmode VALUE=transparent><PARAM NAME=quality VALUE=low><EMBED src=https://sites.google.com/site/corkami/download/demo64.swf WIDTH=800 HEIGHT=602 quality=low loop=false wmode=transparent TYPE="application/x-shockwave-flash" PLUGINSPAGE="http://www.macromedia.com/shockwave/download/index.cgi?P1_Prod_Version=ShockwaveFlash"></EMBED></OBJECT><br/>
</td><td valign=top>
<p>demo of nop / mov / bswap, in 64b</p>
</td></tr></table>



<a name=slide50></a>Slide 50: <a href=#slide49>&lt;&lt; Previous</a> <a href=#slide51>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img50.png border=1 >
</td><td valign=top>
<p>anyone knows what will happen here ?</p>
<p></p>
<p>push, ret.</p>
<p>put an address on the stack, pop it and jump to it.</p>
<p></p>
<p>no possible trick, right...</p>
<p></p>
</td></tr></table>


<a name=slide51></a>Slide 51: <a href=#slide50>&lt;&lt; Previous</a> <a href=#slide52>&gt;&gt; Next</a>
<table><tr><td>
<OBJECT CLASSID="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" WIDTH="800" HEIGHT="602" CODEBASE="http://active.macromedia.com/flash5/cabs/swflash.cab#version=7,0,0,0"><PARAM NAME=movie VALUE=https://sites.google.com/site/corkami/download/pushret.swf><PARAM NAME=play VALUE=true><PARAM NAME=loop VALUE=false><PARAM NAME=wmode VALUE=transparent><PARAM NAME=quality VALUE=low><EMBED src=https://sites.google.com/site/corkami/download/pushret.swf WIDTH=800 HEIGHT=602 quality=low loop=false wmode=transparent TYPE="application/x-shockwave-flash" PLUGINSPAGE="http://www.macromedia.com/shockwave/download/index.cgi?P1_Prod_Version=ShockwaveFlash"></EMBED></OBJECT><br/>
</td><td valign=top>
<p>so, what happened ?</p>
<p>olly even auto-comments the ret!</p>
<p></p>
<p>the 66: before the RETN makes return to IP, not EIP.</p>
<p></p>
<p>so here we returned to 1008, not 401008.</p>
<p></p>
<p>the other problem is that while different, there is no official name for this ret to word, 'small ret', 'ret16'....</p>
</td></tr></table>


<a name=slide52></a>Slide 52: <a href=#slide51>&lt;&lt; Previous</a> <a href=#slide53>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img52.png border=1 >
</td><td valign=top>
<p>I won't enumerate them all.</p>
<p>they're already on Corkami, with some other x86 stuff that might be useful to print.</p>
<p></p>
<p>too much theory with no practice never gives good results...</p>
</td></tr></table>


<a name=slide53></a>Slide 53: <a href=#slide52>&lt;&lt; Previous</a> <a href=#slide54>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img53.png border=1 >
</td><td valign=top>
<p>so I created CoST.</p>
</td></tr></table>


<a name=slide54></a>Slide 54: <a href=#slide53>&lt;&lt; Previous</a> <a href=#slide55>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img54.png border=1 >
</td><td valign=top>
<p>an opcode tester, in a tricky PE.</p>
<p>available in easy mode compile (less tricky), as CoST is quite difficult to debug :)</p>
<p></p>
<p>just run, and it roughly displays what happened.</p>
</td></tr></table>


<a name=slide55></a>Slide 55: <a href=#slide54>&lt;&lt; Previous</a> <a href=#slide56>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img55.png border=1 >
</td><td valign=top>
<p>so, it contains a lot of various tests... (150 is the lower margin, depend how you count)</p>
<p></p>
<p>some trivial... some less trivial.</p>
</td></tr></table>


<a name=slide56></a>Slide 56: <a href=#slide55>&lt;&lt; Previous</a> <a href=#slide57>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img56.png border=1 >
</td><td valign=top>
<p>Cost just gives some output when ran from the command line.</p>
<p></p>
<p>but actually it gives much more output on debug output.</p>
<p></p>
<p>even if the binary is hand-made, it's self documented, via one-line calls to VEH printing, and internal exports for different internal chapters.</p>
</td></tr></table>


<a name=slide57></a>Slide 57: <a href=#slide56>&lt;&lt; Previous</a> <a href=#slide58>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img57.png border=1 >
</td><td valign=top>
<p>here is my favorite part of CoST:</p>
<p></p>
<p>anyone sees what this is doing ?</p>
<p></p>
<p>executing code at push_eip...</p>
<p>then the same code with selector 33 (64b code)</p>
<p></p>
<p>so the same opcodes are executed twice, first in 32b mode, then in 64b.</p>
</td></tr></table>


<a name=slide58></a>Slide 58: <a href=#slide57>&lt;&lt; Previous</a> <a href=#slide59>&gt;&gt; Next</a>
<table><tr><td>
<OBJECT CLASSID="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" WIDTH="800" HEIGHT="602" CODEBASE="http://active.macromedia.com/flash5/cabs/swflash.cab#version=7,0,0,0"><PARAM NAME=movie VALUE=https://sites.google.com/site/corkami/download/96bits.swf><PARAM NAME=play VALUE=true><PARAM NAME=loop VALUE=false><PARAM NAME=wmode VALUE=transparent><PARAM NAME=quality VALUE=low><EMBED src=https://sites.google.com/site/corkami/download/96bits.swf WIDTH=800 HEIGHT=602 quality=low loop=false wmode=transparent TYPE="application/x-shockwave-flash" PLUGINSPAGE="http://www.macromedia.com/shockwave/download/index.cgi?P1_Prod_Version=ShockwaveFlash"></EMBED></OBJECT><br/>
</td><td valign=top>
<p>and these opcodes gives exclusive mnemonics to each side...</p>
<p></p>
<p>works fine under a 64b OS.</p>
<p></p>
<p>same EIP, same opcodes, twice, and different code.</p>
</td></tr></table>


<a name=slide59></a>Slide 59: <a href=#slide58>&lt;&lt; Previous</a> <a href=#slide60>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img59.png border=1 >
</td><td valign=top>
<p>as you'd expect, WinDbg, following Intel docs too closely, will give you '??'</p>
<p></p>
<p>Hiew does that too a little.</p>
<p></p>
<p>but honestly, I found bugs in all disassemblers I looked at, no exception AFAIR. Even a crash in XED.</p>
</td></tr></table>


<a name=slide60></a>Slide 60: <a href=#slide59>&lt;&lt; Previous</a> <a href=#slide61>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img60.png border=1 >
</td><td valign=top>
<p>CoST was originally only an opcode tester.</p>
<p></p>
<p>then I added a few PE tricks...</p>
<p></p>
<p>have a look yourself, the top of the file, and the PE header (right at the bottom)</p>
</td></tr></table>


<a name=slide61></a>Slide 61: <a href=#slide60>&lt;&lt; Previous</a> <a href=#slide62>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img61.png border=1 >
</td><td valign=top>
<p>As you can see, IDA didn't really like it at first (fixed, now)</p>
<p></p>
<p>So, if CoST helps you to find a few bugs in your program, I'm not really surprised.</p>
<p></p>
</td></tr></table>


<a name=slide62></a>Slide 62: <a href=#slide61>&lt;&lt; Previous</a> <a href=#slide63>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img62.png border=1 >
</td><td valign=top>
<p>but one single file, even full of tricks, is not enough to express all the possibilities of the PE file.</p>
<p></p>
<p>so I created more.</p>
</td></tr></table>


<a name=slide63></a>Slide 63: <a href=#slide62>&lt;&lt; Previous</a> <a href=#slide64>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img63.png border=1 >
</td><td valign=top>
<p>I already made some useful graphs for PE files.</p>
<p></p>
<p>and I started a wiki page, with more than 120 PoCs, focusing, as usual, on precise aspects of the PE.</p>
<p></p>
<p>PE with no section, with 64k sections, with huge ImageBase, relocation encryption...</p>
</td></tr></table>


<a name=slide64></a>Slide 64: <a href=#slide63>&lt;&lt; Previous</a> <a href=#slide65>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img64.png border=1 >
</td><td valign=top>
<p>in low alignments, the section table is checked but not used at all.</p>
<p>so, if it's full of zeroes, it will still work – under XP.</p>
<p></p>
<p>thus, with SizeOfOptionalHeader, you can set it in virtual space...</p>
<p></p>
<p>Hiew doesn't like that.</p>
<p>check the picture, it doesn't even identify it as a PE.</p>
</td></tr></table>


<a name=slide65></a>Slide 65: <a href=#slide64>&lt;&lt; Previous</a> <a href=#slide66>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img65.png border=1 >
</td><td valign=top>
<p>what do you think ?</p>
<p></p>
<p>when you can do ASCII art with the PE info, something dodgy is going on :)</p>
<p></p>
<p>this is ReversingLabs' dual PE header.</p>
<p>the PE header is partially overwritten (at exports directories) on loading. </p>
<p></p>
<p>the upper part is read from disk, the lower part, read in memory, is overwritten by the section that is folded over the bottom of the header.</p>
</td></tr></table>


<a name=slide66></a>Slide 66: <a href=#slide65>&lt;&lt; Previous</a> <a href=#slide67>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img66.png border=1 >
</td><td valign=top>
<p>export names can be anything until 0, or even null.</p>
<p></p>
<p>Hiew displays them inline, so, well, here is the PoC of weird export names</p>
<p></p>
<p>one of the other names in this PoC is LOOOONG enough to trigger a buffer overflow &gt;:)</p>
</td></tr></table>


<a name=slide67></a>Slide 67: <a href=#slide66>&lt;&lt; Previous</a> <a href=#slide68>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img67.png border=1 >
</td><td valign=top>
<p>this is a 64k section PE against the latest Olly.</p>
<p></p>
<p>amazingly, it doesn't crash despite this funny message...</p>
</td></tr></table>


<a name=slide68></a>Slide 68: <a href=#slide67>&lt;&lt; Previous</a> <a href=#slide69>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img68.png border=1 >
</td><td valign=top>
<p>this one is not very visual, yet quite unique.</p>
<p></p>
<p>TLS AoI points to an Import descriptor Name member...</p>
<p></p>
<p>depending on AoI or imports happening first, this is a terminator or not...</p>
<p></p>
<p>so the same PE gets loaded with more or less imports depending on the OS.</p>
<p></p>
</td></tr></table>


<a name=slide69></a>Slide 69: <a href=#slide68>&lt;&lt; Previous</a> <a href=#slide70>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img69.png border=1 >
</td><td valign=top>
<p>unlike what I used to believe, cpus and windows binaries are far from perfectly logical nor documented</p>
<p></p>
<p>If you only follow the official doc, you're bound to fail. especially with the malware landscape out there.</p>
</td></tr></table>


<a name=slide70></a>Slide 70: <a href=#slide69>&lt;&lt; Previous</a> <a href=#slide71>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img70.png border=1 >
</td><td valign=top>
<p>so give Corkami PoCs a try – and send me a postcard if you found some bugs</p>
<p></p>
<p>I seriously hope that MS will put WinDbg back to a more reactive release cycle, and will update it...</p>
</td></tr></table>


<a name=slide71></a>Slide 71: <a href=#slide70>&lt;&lt; Previous</a> <a href=#slide72>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img71.png border=1 >
</td><td valign=top>
<p>Eternal thanks to Peter Ferrie, my permanent reviewer.</p>
<p>Ivanlef0u is also very helpful.</p>
<p>a lot of people helped me in the process to make this presentation and the content on corkami, in one way or another.</p>
<p></p>
<p>Any questions?</p>
</td></tr></table>


<a name=slide72></a>Slide 72: <a href=#slide71>&lt;&lt; Previous</a> <a href=#slide73>&gt;&gt; Next</a>
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img72.png border=1 >
</td><td valign=top>
<p>Thanks for your attention. I hope you liked it.</p>
</td></tr></table>


<a name=slide73></a>Slide 73: <a href=#slide72>&lt;&lt; Previous</a> &gt;&gt; Next
<table><tr><td>
<img src=https://corkami.googlecode.com/svn/wiki/pics/bsx2/img73.png border=1 >
</td><td valign=top>
<ul>
<li/>Mips relocs are still working, even with x86 CPU and PE. and relocs can be applied on further relocations... so does my PoC
<li/>Adding an extra relocation on the imagebase doesn't influence the loading (the PE is already mapped), but it interferes with the EP calculation.
<li/>Drivers are just low alignment PEs with different import. so I made a PE with low alig and no imports, that detects how it's ran, and resolves its own imports accordingly
<li/>on TLS and DLLMain return, only ESI and EIP have to be correct, so my PoC corrupts everything else... IDA didn't like a weird ESP...
</ul>
</td></tr></table>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
  ]]>
  </Content>
</Module>